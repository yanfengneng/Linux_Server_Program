本章内容为面试考察重点，之后根据面经再来复盘本章内容。。。

服务器主要分为三个模块：

* **IO 处理单元**：介绍有四种 IO 模型和两种高效事件处理模式。
* **逻辑单元**：介绍两种高校并发模式，以及高效的逻辑处理方式--有限状态机。
* **存储单元**：与网络编程本身无关，本书不进行讨论。



# 8.1 服务器模型

## 8.1.1 C/S 模型

C/S 模型：所有客户端都通过访问服务器来获取所需的资源。

> ![image-20230419163845243](Image/CS模型.png)



**TCP 下的服务器与客户端的工作流程：**

参考：[TCP三次握手和四次挥手详解](https://blog.csdn.net/kakaka666/article/details/126355782)

![image-20230419193250183](Image/三次握手过程解释.png)

> ![image-20230419173444375](Image/TCP服务器与客户端工作流程图（全）.png)
>
> ![6bafd55840d04748a1c88da6d4bd8306](Image/TCP三次握手详细过程.png)

![816045-20161105220355065-482198403](Image/TCP连接与释放全过程.png)



## 8.1.2 P2P 模型

**P2P模型的优点**：使得每台机器在消耗服务的同时，也能给其他人提供服务，能够使资源充分、自由地共享。

**P2P模型的缺点**：主机之间很难相互发现。因此在实际使用的 P2P 模型通常带有一个专门的发现服务器，这个发现服务器通常还提供查找服务（甚至还可以提供内容服务），使得每个客户都能尽快地找到自己需要的资源。

**从编程角度来说：P2P模型可以看出C/S模型的扩展，每台主机即是客户端，又是服务器。**

![image-20230419194003769](Image/P2P模型.png)



# 8.2 服务器编程框架

**服务器基本框架图如下所示：**

![image-20230420213622196](Image/服务器基本框架.png)

**服务器基本模块的功能描述：**

![image-20230520220721493](Image/服务器基本模块的功能描述1.png)

![image-20230520220808229](Image/服务器基本模块的功能描述2.png)

* **IO 处理单元是服务器管理客户连接的模块**。用来等待并接受新的客户连接，接受客户数据，将服务器响应数据返回给客户端。

* **一个逻辑单元通常是一个进程或一个线程**。用来分析并处理客户数据，然后将结果传递给 IO 处理单元或者直接发送给客户端。

* **网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服务器**。网络存储单元不是必须存在，比如 ssh、telnet 等登陆服务就不要这个单元。

* **请求队列是各单元之间通信方式的抽象**。IO 处理单元接收到客户请求，是需要以某种方式通知一个逻辑单元来处理该请求。多个逻辑单元同时访问一个存储单元，也要使用某种机制来协调处理竞态条件。



# 8.3 IO模型

阻塞和非阻塞的概念能应用于所有的文件描述符，包括 socket，称**阻塞的文件描述符为阻塞I/O，非阻塞的文件描述符为非阻塞I/O。**

**阻塞I/O**：当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。注意，**阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程**。socket 基础 API 中，阻塞式的系统调用有 accept、send、recv 和 connect（connect：需要阻塞等待三次握手的完成。accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞）。

**非阻塞I/O**：非阻塞 IO 的系统调用总是立即返回的，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用返回 -1，与出错情况一样。因此我们必须根据 errno 来区分这两种情况。**显然只有在事件已经发生的情况下，操作非阻塞 IO  才能提高程序的效率。因此，非阻塞 IO 通常要和其他 IO 通知机制一起使用，比如 IO 复用和 SIGIO 信号。SIGIO 信号也能用来报告 IO 事件。** 

**I/O 复用：是最常用的 I/O 通知机制。**它是指：应用程序通过 I/O 复用函数向内核注册一组 I/O 事件，内核通过  I/O 复用函数把就绪的事件通知给应用程序。常用的 I/O 复用函数是select、poll、epoll。I/O 复用函数本身是阻塞的，因为它们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。

**同步 IO 模型有阻塞 IO、IO 复用和信号驱动 IO**。<font color=alice>在这三种 IO 模型中， IO 的读写操作都是在 IO 事件发生之后由应用程序完成的。</font>

**对于异步 IO 而言，用户可以直接对 IO 执行读写操作。**这些操作需要告诉内核用户读写缓冲区的位置，以及 I/O 操作完成之后内核通知应用程序的方式。异步 IO 的读写操作总是立即返回，而不论 IO 是否是阻塞的，因为真正的读写操作已经由内核接管。

**同步 IO 向应用程序通知的是 IO 就绪事件，而异步 IO 向应用程序通知的是 IO 完成事件。**

IO 模型对比如下：

![image-20230521151826287](Image/IO模型对比.png)



# 8.4 两种高效的事件处理方式

服务器程序通常要处理三类事件：IO 事件、信号及定时事件。

同步 IO 模型通常用于实现 `Reactor` 模式，异步 IO 模型通常则用于实现 `Proactor` 模式。

## 8.4.1 Reactor 模式



## 8.4.2 Proactor 模式



## 8.4.3 模拟 Proactor 模式





# 8.5 两种高效的并发模式



## 8.5.1 半同步/半异步模式



## 8.5.2 领导者/追随者模式





# 8.6 有限状态机

todo

# 8.7 提高服务器性能的其他建议

池、数据复制、上下文切换和锁。