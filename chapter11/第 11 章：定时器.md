服务器程序通常管理着众多的定时事件，**因此有效地组织这些定时事件，使之在预期时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。**

<font color=blue>因此需要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。</font>

**定时是指在一段时间之后触发某段代码的机制，可以在这段代码中依次处理所有到期的定时器。**

**Linux 提供了三种定时方法：**

* 1）socket 选项 `SO_RCVTIMEO` 和 `SO_SNDTIMEO`。
* 2）`SIGALRM` 信号。
* 3）IO 复用系统调用的超时函数。



# 11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO

`SO_RCVTIMEO` 用来设置 socket 接收数据的超时时间；`SO_SNDTIMEO` 用来设置 socket 发送数据的超时时间。

**这两个选项仅对数据接收和发送相关的 socket 专用系统调用（如：send、sendmsg、recv、recvmsg、accept 和 connect）有效果。**

选项 SO_RCVTIMEO 和 SO_SNDTIMEO 对系统调用的影响如下：

![image-20230504201836626](Image/SO_RCVTIMEO和SO_SNDTIMEO选项的作用.png)



# 11.2 SIGALRM 信号

由 `alarm` 和 `setitimer` 函数设置的实时闹钟一旦超时，将会触发 `SIGALRM` 信号。

<font color=blue>可以使用 `SIGALRM` 信号的信号处理函数来处理定时任务。但是要处理多个定时任务，就需要不断地触发 `SIGALRM` 信号，并在其信号处理函数中执行到期的任务。</font>

## 11.2.1 基于升序链表的定时器

定时器通常至少包含两个成员：**一个超时时间**（相对时间或者绝对时间）和**一个任务回调函数**。

当然有时候成员还需要**包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。**

当使用**链表**来作为容器来串联所有的定时器，则每个定时器还需要包含**指向下一个定时器的指针成员**。