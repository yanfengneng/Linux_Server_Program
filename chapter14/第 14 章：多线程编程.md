# 14.1 Linux 线程概述

## 14.1.1 线程模型

线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。**线程是独立调度的基本单位，进程是拥有资源的基本单位。**

根据运行环境和调度者的身份，线程可分为内核线程和用户线程：

* 1）内核线程：运行在内核空间，由内核来调用，也称为轻量级进程（LWP）。
* 2）用户线程：运行在用户空间，由线程库来调度。

***

<font color=blue>线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度。</font>

a）**完全在用户空间实现：**这种方式实现的线程无需内核的支持，内核甚至根本不知道这些线程的存在。线程库利用 `longjmp` 来切换线程的执行，线程库负责管理所有执行线程，比如：线程的优先级、时间片等。**这种实现方式，相等于是M:1，也就是 M 个用户空间线程对应一个 1 个内核线程，实际上内核线程就是进程自己。**

* 优点：用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快。
* 缺点： 一个进程中的多个线程只能调度到一个CPU，这种约束限制了可用的并行总量。如果某个线程执行了一个“阻塞式”操作（如read），那么，进程中的所有线程都会阻塞，直至那个操作结束。

b）**完全由内核调度**：满足M:N = 1:1，即 1 个用户线程被映射为 1 个内核线程。 在1:1核心线程模型中，应用程序创建的每一个线程（也有书称为LWP）都由一个核心线程直接管理，也就是说一个用户线程对应一个内核线程。OS内核将每一个核心线程都调到系统CPU上。由于这种线程的创建与调度由内核完成，所以这种线程的系统开销比较大（但一般来说，比进程开销小）。

c）**双层调度模式**：内核调用 N 个内核线程，线程库调度 M 个用户线程。这种线程实现方式结合了前两种方式的优点：不但不会消耗过多的内核资源，而且线程切换速度也较快，同时它也可以充分利用多处理器的优势。



## 14.1.2 Linux 线程库

现代 Linux 默认使用的线程库是NPTL（Next Generation POSIX Threads），是采用1:1方式实现的。

```bash
# 用户可以使用该命令查看当前系统使用的线程库：
getconf GNU_LIBPTHREAD_VERSION
```

NPTL的主要有以下几个优点：

* 1）内核线程不再是一个进程，因此避免了很多用进程模拟内核线程导致的语义问题。
* 2）摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成。
* 3）一个进程的线程可以运行在不同的CPU上，能充分利用多处理器的系统的优势。
* 4）线程的同步由内核完成。隶属于不同进程的线程之间也可能共享互斥锁，因此可实现跨进程的线程同步。



# 14.2 创建线程和结束线程

```c++
#include <pthread.h>

int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg); 


void pthread_exit(void* retval);


int pthread_join(pthread_t thread, void** retval);


int pthread_cancel(pthread_t thread);
```



# 14.3 线程属性

```c++

#include <bits/pthreadtypes.h>
#define __SIZEOF_PTHREAD_ATTR_T 36
typedef union
{
    char __size[__SIZEOF_PTHREAD_ATTR_T];
    long int __align;
}pthread_attr_t;
```



# 14.4 POSIX 信号量



# 14.5 互斥锁



# 14.6 条件变量



# 14.7 线程同步机制包装类



# 14.8 多线程环境

